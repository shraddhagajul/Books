a channel serves as a conduit for a stream of information; values may be passed along the channel, and then read out downstream.
pass a value into a chan variable, and then somewhere else in your program read it off the channel.
The disparate parts of your program don't require knowledge of each other, only a reference to the same place in memory where the channel resides. This can be done by passing references of channels around your program.

Sending is done by placing the <- operator to the right of a channel, and receiving is done by placing the <- operator to the left of the channel.
Read
var dataStream <-chan interface{}
dataStream := make(<-chan interface{})

Send
var dataStream chan<- interface{}
dataStream := make(chan<- interface{})

You don't often see unidirectional channels instantiated, but you'll often see them used as function parameters and return types, which is very useful.
This is possible because Go will implicitly convert bidirectional channels to unidirectional channels when needed.

however, it is an error to try and write a value onto a read-only channel, and an error to read a value from a write-only channel. If we try and compile the following example, Go's compiler will let us know that we're doing something illegal:

HelloChannels()
why the anonymous goroutine completes before the main goroutine does;
This example works because channels in Go are said to be blocking. This means that any goroutine that attempts to write to a channel that is full will wait until the channel has been emptied, and any goroutine that attempts to read from a channel that is empty will wait until at least one item is placed on it. In this example, our fmt.Println contains a pull from the channel stringStream and will sit there until a value is placed on the channel. Likewise, the anonymous goroutine is attempting to place a string literal on the stringStream, and so the goroutine will not exit until the write is successful. Thus, the main goroutine and the anonymous goroutine block deterministically.

DeadlockExample()
deadlocks may occurs if we dont structure the program correctely 
fatal error: all goroutines are asleep - deadlock!
goroutine 1 [chan receive]:
main.main()
    /tmp/babel-23079IVB/go-src-230795Jc.go:15 +0x97
    exit status 2

ok:
The second return value is a way for a read operation to indicate whether the read off the channel was a value generated by a write elsewhere in the process, or a default value generated from a closed channel.

ReadFromClosedChannel()
we can read from a closed channel as well.
This is to allow support for multiple downstream reads from a single upstream writer on the channel

RangeOverChannel()
how the loop doesn't need an exit criteria, and the range does not return the second boolean value. The specifics of handling a closed channel are managed for you to keep the loop concise.

buffered channels, which are channels that are given a capacity when they're instantiated. This means that even if no reads are performed on the channel, a goroutine can still perform n writes, where n is the capacity of the buffered channel.
a := make(chan int)
b := make(chan int, 0)

Cox-Buday, Katherine. Concurrency in Go: Tools and Techniques for Developers . O'Reilly Media. Kindle Edition. 
Both channels are int channels with a capacity of zero. Remember that when we discussed blocking, we said that writes to a channel block if a channel is full, and reads from a channel block if the channel is empty? “Full” and “empty” are functions of the capacity, or buffer size. An unbuffered channel has a capacity of zero and so it's already full before any writes. A buffered channel with no receivers and a capacity of four would be full after four writes, and block on the fifth write since it has nowhere else to place the fifth element. Like unbuffered channels, buffered channels are still blocking; the preconditions that the channel be empty or full are just different. In this way, buffered channels are an in-memory FIFO queue for concurrent processes to communicate over.

reading from a nil channel will block (although not necessarily deadlock) a program.
writes to a nil channel will also block.
close a nil channel => panic

The goroutine that owns a channel should: 
1. Instantiate the channel.  
2. Perform writes, or pass ownership to another goroutine.  
3. Close the channel.  
4. Ecapsulate the previous three things in this list and expose them via a reader channel.  
By assigning these responsibilities to channel owners, a few things happen: 
1. Because we're the one initializing the channel, we remove the risk of deadlocking by writing to a nil channel.  
2. Because we're the one initializing the channel, we remove the risk of panicing by closing a nil channel.  
3. Because we're the one who decides when the channel gets closed, we remove the risk of panicing by writing to a closed channel.
4. Because we're the one who decides when the channel gets closed, we remove the risk of panicing by closing a channel more than once.  
5. We wield the type checker at compile time to prevent improper writes to our channel.

blocking operations that can occur when reading.
1. Knowing when a channel is closed. 
2. Responsibly handling blocking for any reason.

example :

Here we instantiate a buffered channel. Since we know we’ll produce six results, we create a buffered channel of five so that the goroutine can complete as quickly as possible. 
Here we start an anonymous goroutine that performs writes on resultStream. Notice that we’ve inverted how we create goroutines. It is now encapsulated within the surrounding function. 
Here we ensure resultStream is closed once we’re finished with it. As the channel owner, this is our responsibility. 
Here we return the channel. Since the return value is declared as a read-only channel, resultStream will implicitly be converted to read-only for consumers.

Cox-Buday, Katherine. Concurrency in Go: Tools and Techniques for Developers . O'Reilly Media. Kindle Edition. 

